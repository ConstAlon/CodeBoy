<style> 
	div{
	font-famliy:"楷体"
}
</style>
<div class="one">

## 操作系统学习笔记(二) 
1. [进程概述](#进程概述)
	1. [进程的概念和特征](#进程的概念和特征)
	2. [进程的状态](#进程的状态)
	3. [进程的组织](#进程的组织)

## 进程概述

##### 进程的概念和特征

1. 进程的概念
	1. 程序：是静态的，存放在磁盘里的可执行文件，就是一系列指令集合。
	2. 进程：是动态的，是程序的依次执行过程。

2. 进程的组成
	1. PCB（进程存在的唯一标志）
		1. 进程描述信息
		2. 进程控制和管理信息
		3. 资源分配清单
		4. 处理机相关信息
	2. 程序段 --- 程序的代码（指令序列）。
	3. 数据段 --- 运行过程中产生的各种数据。 


> <font color=red>当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID号---PID（进程ID，Process iD）。</font>
> - - - 
> 一个进程实体（进程映像）由PCB、程序段、数据段组成。
进程是动态的，进程实体（进程映像）是静态的。 
 
 - 程序段、数据段、PCB三部分组成了进程实体。
- 进程是进程实体的与运行过程，是系统进行资源分配和调度的一个独立单位。

3. 进程的特征
	1. 动态性 ：进程是程序的依次执行过程，是动态的产生、变化和消亡。<font color=red>**进程最基本的特征**</font>
	2. 并发性：内存中有多个进程实体，各进程可并发执行。
	3. 独立性：<font color=red>***进程是能独立运行、独立获得资源、独立接受调度的基本单位。***</font>
	4. 异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供”进程同步机制“来解决异步问题。<font color=red>**会导致程序的不确定性。**</font>
	5. 结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成。


##### 进程的状态
1. 创建态

> 进程正在被创建时，则为创建态，操作系统会为进程分配资源、初始化PCB。

2. 就绪态

> 当进程完成创建后，就会进入就绪态。该阶段进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行。

3. 运行态

> 如果一个进程此时在CPU上运行，那么这个进程处于运行态。CPU会执行该进程对应的程序。

4. 阻赛态

> 在进程运行过程中，可能会请求等待某个事件发生。在这个事件发生之前，进程无法继续往下执行，此时操作系统让这个进程下CPU，并让它进入阻塞态。
> 
> 当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行。

5. 终止态

> 一个进程可以执行exit系统调用，请求操作系统终止该进程。
> 
> 此时该进程会进入终止态，操作系统会让该进程下CPU，并收回内存空间等资源，最后还要收回该进程的PCB。
> 
> 当终止进程的工作完成后，这个进程就彻底消失了。

6. 进程状态的转换

> <font color=red>注意： 不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态。</font>
> 
> 1-3基本状态，在整个生命周期中，大部分时间都处在这三种转态。
> - - -
> 进程PCB中，会有一个变量state来表示进程的当前状态。

##### 进程的组织
1. 链接方式

>使用指针来指向各个状态的进程的PCB
>- - -
>按照进程状态将PCB分为多个队列
>操作系统持有指向各个队列的指针

2. 索引方式

> 根据进程状态不同，建立几张索引表
> 操作系统持有指向各个索引表的指针

## 进程控制

什么是进程控制？

> 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。<font color=blue>就是进程状态转换</font>

如何实现进程控制？

> 用“原语”实现
> 原语的执行具有“原子性”，一气呵成。
>  - - -
>  至少做两件事：
> 将PCBx中的state设置为就绪状态1
> 将PCBx从阻塞队列删除  

原语中的“原子性”

> 原语的执行具有“原子性”，一气呵成。期间不允许被中断
> “关中断”和“开中断”指令，这两个特权指令实现了原子性

##### 进程的创建

创建原语

> 申请空白PCB
> 为新进程分配所需资源
> 初始化PCB
> 将PCB插入就绪队列

引起进程创建的事件

> 用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程。
> 作业调度：多道批处理系统，由新的作业放入内存时，会为其建立一个新的进程。
> 提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求。
> 应用请求：由用户进程主动请求一个子进程。

##### 进程的终止

撤销原语

>  从PCB集合中找到终止进程的PCB。
>  若进程正在运行，立即剥夺CPU，将CPU分配给其他进程。
>  终止其所有子进程。(进程之间的关系是树形结构)
>  将该进程拥有的所有资源归还给父进程或操作系统。

引起进程终止的事件

> 正常结束（进程自己请求终止（exit系统调用））。
> 异常结束（整数除以0，非法使用特权指令，然后被操作系统强行杀掉）。
> 外界干预（Ctrl+Alt+Delete，用户选择杀掉进程）。

##### 进程的阻塞和唤醒

阻塞原语

> 找到要阻塞的进程对应的PCB。
> 保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行。
> 将PCB插入相应事件的等待队列。

引起进程阻塞的事件

> 需要等待系统分配某种资源。
> 需要等待相互配和的其他进程完成工作。

唤醒原语

> 在事件等待队列中找到PCB。
> 将PCB从等待队列移除，设置进程为就绪态。
> 将PCB插入就绪队列，等待被调度。

引起进程唤醒的事件

> 等待事件发生。

注意：唤醒原语和阻塞原语必须成对出现。

##### 进程控制

切换原语

> 将运行环境信息存入PCB。
> PCB移入相应队列。
> 选择另一个进程执行，并更新其PCB。
> genjuPCB恢复新进程所需的运行环境。

引起进程切换的事件

> 当前进程时间片到。
> 有更高优先级的进程到达。
> 当前进程主动阻塞。
> 当前进程终止。
    
## 进程通信

什么是进程通信

> 就是指进程之间的信息交换
> 晋城市分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。
> - - -
> 为了保证安全，一个进程不能直接访问另一个进程的地址空间，但还是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。
> 


##### 共享存储
> 两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）
> 操作系统只负责提供共享空间和同步互斥工具 
> - - -
> <font color=red>基于数据结构的共享</font>：比如共享空间里面只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。
> <font color=red>基于存储区的共享</font>：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。


## 线程

什么是线程，为什么引入线程

> 传统的进程只能串行执行一系列程序，因此引入线程，来增加并发度。
> 引入线程后，线程成为了程序执行流的最小单位。
> - - - 
> 线程是一个基本的CPU执行单位，也是程序执行流的最小单位；不仅在进程间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度。
> - - -
> 引入线程后，进程只作为除CPU之外的系统资源分配单位。

引入线程后，带来的变化

> 资源分配、调度
> 并发性
> 系统开销

##### 线程的属性

1. 线程是处理机调度的单位
2. 多CPU计算机中，各个线程可占用不同的CPU
3. 每个线程都有一个线程ID、线程控制块（TCB）
4. 线程也有就绪、阻塞、运行三态
5. 线程几乎不拥有系统资源
6. 统一进程的不同线程间共享进程的资源
7. 由于共享内存地址空间，统一进程中的线程间通信甚至无需系统干预
8. 同一进程中的线程切换，不会引起进程切换
9. 不同进程中的线程切换，会引起进程切换
10. 切换同进程内的线程，系统开销很小
11. 切换进程，系统开销较大

##### 线程的实现方式

1. 用户级线程（User—Level Thread，ULT）

> 很多编程语言提供了强大的线程库。
> 所有线程管理工作都是由应用程序负责。
> 线程切换可以在用户态下即可完成，无需操作系统干预。
> - - - 
> 优点：
> 用户级线程的切换在用户空间即可完成，不需要切换到内核态，线程管理的系统开销小，效率高。
> 缺点：
> 当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可再多核处理机上并行运行。

2. 内核级线程（Kernel-Level Thread，KLT，又称“内核支持的线程”）

>内核级线程的管理工作由操作系统内核完成。
> 内核级线程的切换必然需要在核心态下才能玩成。
> 操作系统会为每个内核级线程创建相应的TCB（Thread Control Block，线程控制块）。
>  - - -
> 优点：
> 当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
> 缺点：
> 一个用户进程会占用多个内核级线程，线程切换由操作系统内核来完成，需要切换到内核态，因此线程管理的成本高，开销大。

##### 多线程模型

1. 一对一模型：

> 一个用户线程映射到一个内核级线程。

2. 多对一模型：

> 多个用户级线程映射到一个内核级线程。

3. 多对多模型：

> n用户级线程映射到n内核级线程。
> 集上面两个之所长


重点：操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配单位。

用户级线程：代码逻辑的载体
内核级线程：运行机会的载体


## 调度

调度基本概念

>当有一丢i任务要处理，但由于资源有限，这些事情没法同时处理。这就需要请确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。 

##### 调度的三个层次

1. 高级调度（作业调度）（最低发生频率）

> 按一定的原则从外存的作业后备队列中挑出一个作业调入内存，并创建进程。每个作业只调入一次，调出依次。作业调入时会建立PCB，调出时才撤销PCB。

2. 低级调度（进程调度/处理机调度）（中等发生频率）

> 按照某种策略从就绪队列中选取一个进程，将处理机分配给它。
> 进程调度时操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。
> 进程调度的频率很高，一般几十毫秒一次。

3. 中级调度（内存调度）（最高发生频率）

内存不够时，可以将某些进程的数据调出外存。等内存空闲或者进程需要运行时在重新调入内存。
暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列。

> 按照某种策略决定将那个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。


补充：进程的挂起状态与七状态模型

> 暂时调到外存等待的进程状态为挂起状态（挂起态，suspend）
> 挂起态分为：就绪挂起、阻塞挂起


 ## 调度时机、切换
 
 ##### 时机
 
 需要进行进程调度与切换
 
1. 当前运行的进程互动放弃
2. 当前运行的进程被动放弃 

不能进行进程调度与切换

1. 在处理中断的过程中。
2. 进程在操作系统内核程序临界区中。
3. 在原子操作过程中（原语）。

临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥的访问临界资源。
临界区：访问临界资源的那段代码。
内核程序临界区一般是用来访问某种内核数据结构的。

但是进程在普通临界区是可以调度、切换的。

##### 调度方式

1. 非剥夺调度方式，非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，知道该进程终止或主动要求进入人阻塞态。

注意： 实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。

2. 剥夺调度方式，抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。

注意：可以优先处理更紧急的进程，也可以实现让各进程按时间片轮流执行的功能。适合于分时操作系统、实时操作系统。

##### 进程切换与过程

狭义的进程调度指的是从就绪队列中选中一个要运行的进程。

进程切换是指一个进程让出处理机，有另一个进程占用处理机的过程。

广义的进程调度包含了选择一个进程和进程切换。

1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复。

注意：进程切换是有代价的，因为如果过于频繁的进行进程的调度、切换，必然会使整个系统的效率降低，使系统大部分时间画在进程切换上，而真正用在执行进程的时间减少。



##### 调度算法的评价指标

1. CPU利用率

> 值CPU忙碌的时间占总时间的比例。
>
>利用率= 忙碌时间 / 总时间


2. 系统吞吐量

>单位时间内完成作业的数量
>
>系统吞吐量 = 总共完成多少道作业 /  总共花了多少时间
>

3. 周转时间

>指从作业提交给系统开始，到作业完成位置的这段时间间隔。
>
> 周转时间 = 作业完成时间 - 作业提交时间
> 
>平均周转时间 = 各作业周转时间之和 / 作业数
>
>带权周转时间 = 作业周转时间 / 作业实际运行的时间 = 作业完成时间 - 作业提交时间 / 作业实际运行的时间
>
>平均带权周转时间 = 各作业带权周转时间和 / 作业数
>

4. 等待时间

>指进程/作业处于等待处理机状态时间之和。
>
>对进程来说，就是至进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。
>
>对作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后被队列中等待的时间，
>

5. 响应时间

> 指从用户提交申请到首次产生响应所用的时间。
>

##### 调度算法

1. 先来先服务（FCFS，First Come First Serve） 

   1. 算法思想
	  
	 > 主要从公平的角度考虑

    2. 算法规则

	> 按照作业/进程到达的先后顺序进行服务

	3. 用于作业/进程调度

	> 用于作业调度时，考虑的是那个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列。

	4. 是否可抢占

 	> 非抢占式算法

	5. 优缺点

	> 优点：公平、算法实现简单
	> 
	> 缺点：排在长作业进程后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。FCFS算法对长作业有利，对短作业不利。

	6. 是否会导致饥饿

	> 不会

##### 短作业优先（SJF，Shortest Job First）

1. 算法思想
	  
	 > 追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间

    2. 算法规则

	> 优先得到服务是最短的作业/进程

	3. 用于作业/进程调度

	> 即可用于作业调度，也可用于进程调度。用于进程调度时成为“[短进程优先](#短进程优先)（SPF，Shortest Process）算法”

	4. 是否可抢占

 	>SJF和SPF是非抢占式的算法。但是也有抢占式的版本--[最短剩余时间优先算法](#最短剩余时间优先)（SRTN，Shortest Remaining Time Next）

	5. 优缺点

	> 优点：最短的平均等待时间、平均周转时间
	> 
	> 缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。

	6. 是否会导致饥饿

	> 会


注意 ： 
<font  color=blue face=“”>1. 如果题目中为特别说明，所提到的“短作业/进程优先算法”默认是非抢占式的
2. 很多书上说“SJF调度算法的平均等待时间、平均周转时间最少”，严格来说是不对的，应该加上一个条件——“在所有进程同时可运行时，采用SJF调度算法的平均等待时间、平均周转时间最少”。如果不加上述条件，则应该说“抢占式的短作业/进程优先调度算法（[最短剩余时间优先算法](#最短剩余时间优先)的平均等待时间、平均周转时间最少”）
3. 虽然严格来说，SJF的平均等待时间、平均周转时间不一定最少，但相比于其他算法（FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间。
</font>

##### 高响应比优先（HRRN，Highest Response Ratio Next)

1. 算法思想
	  
	 > 要综合考虑作业/进程的等待时间和要求服务的时间

    2. 算法规则

	> 每次调度时先计算各个作业/进程的响应比最高的作业/进程为其服务
	> - - -
	> 响应比 = ( 等待时间 + 要求服务时间 )  /  要求服务时间

	3. 用于作业/进程调度

	> 即可用于作业调度，也可用于进程调度。

	4. 是否可抢占

 	>非抢占式算法。

	5. 优缺点

	> 综合考虑了等待时间和运行时间（要求服务时间）等待时间相同，要求服务时间短的优先（SJF的优点），要求服务时间相同时，等待时间长的优先（FCFS的优点），对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿问题。

	6. 是否会导致饥饿
   
	> 不会 

注意：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但时不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合于早期的批处理系统，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。

##### 时间片轮转调度

1. 算法思想
	  
	 > 公平地、轮流地为各个进程服务，让每个进程在一定时间内都可以得到响应

    2. 算法规则

	> 按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。

	3. 用于作业/进程调度

	> 用于进程调度

	4. 是否可抢占

 	>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式算法。由时钟装置发出时钟中断来通知CPU时间片已到

	5. 优缺点

	> 优点：最短的平均等待时间、平均周转时间
	> 
	> 缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。

	6. 是否会导致饥饿

	> 会

##### 优先级调度

1. 算法思想
	  
	 > 追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间

    2. 算法规则

	> 优先得到服务是最短的作业/进程

	3. 用于作业/进程调度

	> 即可用于作业调度，也可用于进程调度。用于进程调度时成为“[短进程优先](#短进程优先)（SPF，Shortest Process）算法”

	4. 是否可抢占

 	>SJF和SPF是非抢占式的算法。但是也有抢占式的版本--[最短剩余时间优先算法](#最短剩余时间优先)（SRTN，Shortest Remaining Time Next）

	5. 优缺点

	> 优点：最短的平均等待时间、平均周转时间
	> 
	> 缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。

	6. 是否会导致饥饿

	> 会

##### 






</div>







































